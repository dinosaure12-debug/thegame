<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>The Game – Solo & Multijoueur</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg:#050f1f;
      --text:#f9fafb;
      --muted:rgba(191,219,254,.78);
      --accent:#f97316;

      --panelBorder: rgba(147,197,253,.16);
      --panelBgTop: rgba(7,23,48,.78);
      --panelBgBot: rgba(6,18,37,.72);

      /* Texture carte mate/granuleuse (SVG) */
      --cardSvg: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' width='360' height='520' viewBox='0 0 360 520'>\
  <defs>\
    <linearGradient id='g' x1='0' x2='1' y1='0' y2='1'>\
      <stop offset='0' stop-color='%23131b2b'/>\
      <stop offset='1' stop-color='%230b1220'/>\
    </linearGradient>\
    <radialGradient id='shine' cx='25%25' cy='18%25' r='65%25'>\
      <stop offset='0' stop-color='white' stop-opacity='.18'/>\
      <stop offset='.55' stop-color='white' stop-opacity='.05'/>\
      <stop offset='1' stop-color='white' stop-opacity='0'/>\
    </radialGradient>\
    <filter id='grain'>\
      <feTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/>\
      <feColorMatrix type='matrix' values='1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 .10 0'/>\
    </filter>\
  </defs>\
  <rect x='0' y='0' width='360' height='520' rx='34' fill='url(%23g)'/>\
  <rect x='0' y='0' width='360' height='520' rx='34' fill='url(%23shine)'/>\
  <rect x='18' y='18' width='324' height='484' rx='28' fill='none' stroke='white' stroke-opacity='.10' stroke-width='4'/>\
  <rect x='26' y='26' width='308' height='468' rx='26' fill='none' stroke='white' stroke-opacity='.08' stroke-width='2'/>\
  <rect x='0' y='0' width='360' height='520' rx='34' filter='url(%23grain)' opacity='.9'/>\
</svg>");
    }

    *{ box-sizing:border-box; }

    /* ===== BLUEPRINT BACKGROUND (plateau global) ===== */
    body{
      margin:0;
      font-family: Arial, sans-serif;
      color: var(--text);
      display:flex;
      flex-direction:column;
      align-items:center;
      padding: 14px 10px 24px;

      background:
        radial-gradient(900px 550px at 20% 10%, rgba(96,165,250,.18), transparent 60%),
        radial-gradient(900px 550px at 80% 25%, rgba(56,189,248,.12), transparent 60%),
        radial-gradient(900px 550px at 60% 85%, rgba(59,130,246,.10), transparent 60%),

        /* grille fine */
        linear-gradient(to right, rgba(147,197,253,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(147,197,253,.08) 1px, transparent 1px),

        /* grille épaisse */
        linear-gradient(to right, rgba(147,197,253,.12) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(147,197,253,.12) 1px, transparent 1px),

        /* base blueprint */
        linear-gradient(180deg, #061225, #050f1f);

      background-size:
        auto, auto, auto,
        18px 18px,
        18px 18px,
        90px 90px,
        90px 90px,
        auto;

      background-position:
        center, center, center,
        0 0,
        0 0,
        0 0,
        0 0,
        center;

      background-attachment: fixed;
    }

    .container{ width:100%; max-width:980px; display:flex; flex-direction:column; gap:12px; }

    .header{
      display:flex; flex-direction:column; gap:4px;
      padding: 14px;
      border:1px solid var(--panelBorder);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border-radius:16px;
    }
    .header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .subtitle{ font-size:12px; color:var(--muted); }

    /* ===== PANELS BLUEPRINT ===== */
    .setup, .statusline, .boardWrap, .handWrap{
      position:relative;
      border: 1px solid var(--panelBorder);
      background:
        radial-gradient(700px 260px at 20% 0%, rgba(96,165,250,.10), transparent 55%),
        radial-gradient(700px 260px at 85% 30%, rgba(56,189,248,.08), transparent 55%),
        linear-gradient(180deg, var(--panelBgTop), var(--panelBgBot));
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      border-radius: 16px;
    }

    /* Repères de coupe (crop marks) sur certains panneaux */
    .boardWrap::before, .handWrap::before{
      content:"";
      position:absolute;
      inset:10px;
      border-radius: 12px;
      pointer-events:none;
      opacity:.7;
      background:
        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) left top/18px 2px no-repeat,
        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) left top/2px 18px no-repeat,

        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) right top/18px 2px no-repeat,
        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) right top/2px 18px no-repeat,

        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) left bottom/18px 2px no-repeat,
        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) left bottom/2px 18px no-repeat,

        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) right bottom/18px 2px no-repeat,
        linear-gradient(rgba(147,197,253,.40), rgba(147,197,253,.40)) right bottom/2px 18px no-repeat;
    }

    /* “Cartouche” plan (title block) */
    .titleblock{
      position:absolute;
      right:12px;
      bottom:12px;
      border: 1px solid rgba(147,197,253,.20);
      background: rgba(2,10,24,.22);
      color: rgba(219,234,254,.90);
      border-radius: 12px;
      padding: 10px 10px;
      min-width: 220px;
      font-size: 11px;
      line-height: 1.25;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
    }
    .titleblock .k{ color: rgba(191,219,254,.78); }
    .titleblock .v{ font-weight: 800; color: rgba(219,234,254,.92); text-align:right; }

    /* Setup */
    .setup{
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:flex-start;
      padding: 12px;
    }
    .setup .group{
      display:flex; flex-wrap:wrap; gap:8px;
      align-items:center;
      padding:10px;
      border: 1px solid rgba(147,197,253,.14);
      background: linear-gradient(180deg, rgba(2,10,24,.22), rgba(2,10,24,.12));
      border-radius:14px;
    }

    .label{ font-size:12px; color:var(--muted); margin-right:2px; }
    .boardTitle, .hand-title, .hint, .subtitle{ color: var(--muted); }

    input{
      padding:8px 10px;
      border-radius:9999px;
      border:1px solid rgba(147,197,253,.18);
      background: rgba(2,10,24,.22);
      color: var(--text);
      font-size:12px;
      outline:none;
      width: 120px;
    }
    input:focus{
      border-color: rgba(96,165,250,.55);
      box-shadow: 0 0 0 3px rgba(96,165,250,.15);
    }

    .badge{
      padding:6px 10px;
      border-radius:9999px;
      border:1px solid rgba(147,197,253,.18);
      font-size:12px;
      color: rgba(219,234,254,.90);
      white-space:nowrap;
      background: rgba(2,10,24,.22);
    }

    .btn{
      padding:8px 12px;
      border-radius:9999px;
      border:1px solid rgba(147,197,253,.16);
      background: rgba(2,10,24,.22);
      color: var(--text);
      font-weight:800;
      cursor:pointer;
      font-size:12px;
      transition: transform .08s ease, box-shadow .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(96,165,250,.40); }
    .btn:active{ transform: translateY(0px); }

    .btn-primary{
      background: linear-gradient(180deg, rgba(249,115,22,.95), rgba(249,115,22,.80));
      border-color: rgba(249,115,22,.85);
      color:#0b1220;
      box-shadow: 0 10px 22px rgba(249,115,22,.18);
    }
    .btn-danger{
      background: rgba(239,68,68,.18);
      border-color: rgba(239,68,68,.35);
    }

    .statusline{
      padding: 10px 12px;
      display:flex; flex-direction:column; gap:6px;
    }
    .info{ font-size:13px; color: rgba(255,255,255,.90); line-height:1.35; }
    .status{ font-size:13px; color:#fbbf24; min-height:18px; }

    /* Plateau */
    .boardWrap{
      display:flex; flex-direction:column; gap:12px;
      padding: 14px;
      overflow:hidden;
    }
    .boardTitleRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .boardTitle{ font-size:13px; }
    .hint{ font-size:12px; opacity:.95; }

    .board{ display:flex; flex-direction:column; align-items:center; gap:12px; padding: 6px 0 40px 0; }
    .pile-row{ display:flex; align-items:center; gap:12px; }

    .base-card{
      width:56px; height:84px;
      border-radius:12px;
      border:1px solid rgba(147,197,253,.16);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(2,10,24,.20);
      color: rgba(219,234,254,.92);
      font-weight:900; font-size:16px;
    }
    .base-dir{ font-size:13px; margin-top:2px; color: rgba(191,219,254,.78); }

    .controls{ display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-top: 2px; }

    /* Main */
    .handWrap{
      padding: 14px;
      display:flex; flex-direction:column; gap:10px;
    }
    .handTitleRow{ display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .hand-title{ margin:0; font-size:13px; }
    .hand{ display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }

    /* ===== CARTES MATES / GRANULEUSES (sans texte inutile) ===== */
    .card{
      position:relative;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.16);
      background-image: var(--cardSvg);
      background-size: cover;
      background-position: center;
      box-shadow: 0 12px 28px rgba(0,0,0,.40);
      user-select:none;
      overflow:hidden;

      /* couleurs dynamiques (calque léger) */
      --c1: rgba(59,130,246,.30);
      --c2: rgba(239,68,68,.30);
    }

    /* Calque couleur (léger) pour donner de la vie */
    .card::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(135deg, var(--c1), var(--c2));
      opacity:.33;
      mix-blend-mode: screen;
      pointer-events:none;
    }

    /* Reflet discret */
    .card::after{
      content:"";
      position:absolute; inset:-20% -30% auto auto;
      width:140%; height:70%;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,.18), transparent 60%);
      transform: rotate(10deg);
      opacity:.55;
      pointer-events:none;
    }

    /* Numéro uniquement */
    .card .big{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:950;
      letter-spacing:.2px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 10px 24px rgba(0,0,0,.55);
      z-index:2;
    }

    /* Main */
    .hand-card{
      width:74px; height:112px;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease, filter .12s ease;
    }
    .hand-card:hover{
      transform: translateY(-4px);
      box-shadow: 0 18px 36px rgba(0,0,0,.50);
      border-color: rgba(249,115,22,.45);
    }
    .hand-card.selected{
      transform: translateY(-8px) rotate(-2deg);
      border-color: rgba(249,115,22,.85);
      box-shadow: 0 0 0 2px rgba(249,115,22,.35), 0 22px 44px rgba(0,0,0,.55);
      filter: saturate(1.15) brightness(1.05);
    }
    .hand-card.disabled{ opacity:.45; cursor:default; transform:none; box-shadow:none; }

    /* Piles */
    .pile-card{
      width:88px; height:120px;
      border:none; padding:0;
      cursor:pointer;
      transition: transform .10s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;
    }
    .pile-card:hover{ transform: translateY(-2px); }
    .pile-card:disabled{ opacity:.45; cursor:default; transform:none; box-shadow:none; }

    .pile-card.playable{
      box-shadow: 0 0 0 2px rgba(249,115,22,.35), 0 22px 44px rgba(249,115,22,.18);
      filter: saturate(1.15) brightness(1.06);
    }
    .pile-card.not-playable{
      opacity:.35;
      filter: grayscale(.35) brightness(.90);
    }

    .hand-card .big{ font-size:28px; }
    .pile-card .big{ font-size:34px; }

    /* Animation carte volante */
    .flying-card{
      position: fixed;
      z-index: 9999;
      pointer-events:none;
      transform: translate3d(0,0,0);
      will-change: transform, opacity;
      width:74px; height:112px;
      opacity:1;
    }
    .flying-card .big{ font-size:28px; }

    /* Écran fin de partie */
    .overlay{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 10000;
    }
    .overlay.show{ display:flex; }

    .modal{
      width: min(520px, 100%);
      border-radius: 18px;
      border:1px solid rgba(147,197,253,.18);
      background:
        radial-gradient(700px 260px at 20% 0%, rgba(96,165,250,.10), transparent 55%),
        radial-gradient(700px 260px at 85% 30%, rgba(56,189,248,.08), transparent 55%),
        linear-gradient(180deg, rgba(7,23,48,.95), rgba(6,18,37,.92));
      box-shadow: 0 22px 60px rgba(0,0,0,.55);
      padding: 18px;
      display:flex; flex-direction:column; gap:12px;
    }
    .modal h2{ margin:0; font-size:18px; }
    .modal p{ margin:0; color: rgba(219,234,254,.88); line-height:1.4; font-size:13px; }
    .modal .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .statGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat{
      border:1px solid rgba(147,197,253,.14);
      background: rgba(2,10,24,.22);
      border-radius: 14px;
      padding: 10px;
      display:flex; flex-direction:column; gap:4px;
    }
    .stat .k{ font-size:12px; color: rgba(191,219,254,.78); }
    .stat .v{ font-size:16px; font-weight:950; color: rgba(219,234,254,.92); }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>The Game – Solo & Multijoueur</h1>
    </div>

    <div class="setup">
      <div class="group">
        <span class="badge" id="mode-badge">Mode : solo local</span>
        <span class="badge" id="room-info"></span>
        <span class="badge" id="turn-badge"></span>
      </div>

      <div class="group">
        <span class="label">Pseudo</span>
        <input id="name-input" type="text" maxlength="12" placeholder="Pseudo" />
        <button id="btn-save-name" class="btn">Valider</button>
      </div>

      <div class="group">
        <button id="btn-solo" class="btn">Mode solo</button>
        <button id="btn-create-online" class="btn">Créer partie</button>
        <input id="join-code-input" type="text" maxlength="6" placeholder="Code" />
        <button id="btn-join-online" class="btn">Rejoindre</button>
      </div>
    </div>

    <div class="statusline">
      <div id="info" class="info"></div>
      <div id="status" class="status"></div>
    </div>

    <div class="boardWrap">
      <div class="boardTitleRow">
        <div class="boardTitle">Plateau</div>
      </div>

      <div class="board">
        <div class="pile-row">
          <div class="base-card">100<div class="base-dir">↓</div></div>
          <button class="pile-card card" id="pile-0"></button>
        </div>
        <div class="pile-row">
          <div class="base-card">100<div class="base-dir">↓</div></div>
          <button class="pile-card card" id="pile-1"></button>
        </div>
        <div class="pile-row">
          <div class="base-card">1<div class="base-dir">↑</div></div>
          <button class="pile-card card" id="pile-2"></button>
        </div>
        <div class="pile-row">
          <div class="base-card">1<div class="base-dir">↑</div></div>
          <button class="pile-card card" id="pile-3"></button>
        </div>
      </div>

      <div class="controls">
        <button id="new-game" class="btn btn-danger">Reset</button>
        <button id="end-turn" class="btn btn-primary">Finir tour</button>
      </div>

    <div class="handWrap">
      <div class="handTitleRow">
        <div class="hand-title">Ta main</div>
      </div>
      <div id="hand" class="hand"></div>
    </div>
  </div>

  <div id="end-overlay" class="overlay">
    <div class="modal">
      <h2>Félicitations !</h2>
      <p>Vous avez joué toutes les cartes. Bravo, performance parfaite.</p>

      <div class="statGrid">
        <div class="stat"><div class="k">Deck restant</div><div class="v" id="end-deck">0</div></div>
        <div class="stat"><div class="k">Total restant (deck + mains)</div><div class="v" id="end-total">0</div></div>
      </div>

      <div class="row">
        <button id="btn-video" class="btn">Voir la vidéo “Bravo”</button>
        <button id="btn-close-end" class="btn">Fermer</button>
        <button id="btn-replay" class="btn btn-primary">Rejouer</button>
      </div>
    </div>
  </div>

  <script>
    /******** FIREBASE ********/
    const firebaseConfig = {
      apiKey: "AIzaSyCRRVuWD29vt6qgp1iEBfPha-mNRQO2C54",
      authDomain: "the-game-80e93.firebaseapp.com",
      projectId: "the-game-80e93",
      storageBucket: "the-game-80e93.firebasestorage.app",
      messagingSenderId: "147107639100",
      appId: "1:147107639100:web:448b58c01837884bd33839"
    };

    let firebaseAvailable = true;
    try { firebase.initializeApp(firebaseConfig); }
    catch(e){ console.warn("Firebase error:", e); firebaseAvailable = false; }
    const db = firebaseAvailable ? firebase.firestore() : null;

    /******** CONSTANTES ********/
    const HAND_SIZE = 8;
    const MIN_PLAYS_PER_TURN = 2;
    const BRAVO_VIDEO_URL = "https://youtu.be/I2YhWaUDtXg?si=ijeNEmaf2hXkSL2j";

    /******** ETAT APP ********/
    let mode = "solo"; // "solo" | "online"
    let state = null;
    let selectedIndex = null;

    let localPlayerId = localStorage.getItem("thegame_player_id");
    if(!localPlayerId){
      localPlayerId="player-"+Math.random().toString(36).substring(2,10);
      localStorage.setItem("thegame_player_id",localPlayerId);
    }

    let localName = localStorage.getItem("thegame_name") || "";
    const nameInput = document.getElementById("name-input");
    nameInput.value = localName;

    let currentRoomCode = null;
    let roomRef = null;
    let unsubscribeRoom = null;
    let lastRoomData = null;

    let lastSelectedCardEl = null;

    /******** UI helpers ********/
    function setStatus(t){ document.getElementById("status").innerText = t || ""; }
    function setInfo(t){ document.getElementById("info").innerHTML = t || ""; }

    function updateModeBadge(){
      document.getElementById("mode-badge").textContent =
        (mode==="solo") ? "Mode : solo local" : "Mode : multijoueur";
    }
    function updateRoomInfo(){
      document.getElementById("room-info").textContent =
        (mode==="online" && currentRoomCode) ? ("Partie : "+currentRoomCode) : "";
    }
    function getPlayerName(pid){
      const p = lastRoomData?.players?.[pid];
      return (p?.name) ? p.name : pid.slice(-4);
    }
    function updateTurnBadge(){
      const el = document.getElementById("turn-badge");
      if(mode!=="online" || !state?.currentPlayerId){ el.textContent = ""; return; }
      el.textContent = "C'est à " + getPlayerName(state.currentPlayerId) + " de jouer";
    }

    /******** MOTEUR ********/
    const sortAsc = (a)=> Array.isArray(a) ? a.sort((x,y)=>x-y) : a;

    function canPlay(pile, card){
      const v=pile.value;
      return pile.ascending ? (card>v || card===v-10) : (card<v || card===v+10);
    }

    function ensure(st, pid){
      st.hands ??= {};
      st.hands[pid] ??= [];
      st.playsThisTurnByPlayer ??= {};
      st.playsThisTurnByPlayer[pid] ??= 0;
      st.playerOrder ??= [];
      if(!st.playerOrder.includes(pid)) st.playerOrder.push(pid);
      if(!st.currentPlayerId) st.currentPlayerId = st.playerOrder[0] || pid;
      return st.hands[pid];
    }

    function totalRemaining(st){
      const deck = st.deck?.length || 0;
      const hands = Object.values(st.hands || {}).reduce((s,h)=>s+(h?.length||0),0);
      return deck + hands;
    }

    function isMyTurn(st, pid){
      return !st?.currentPlayerId || st.currentPlayerId === pid;
    }

    function nextPlayer(st, pid){
      const order = st.playerOrder || [];
      if(order.length === 0) return pid;
      const idx = order.indexOf(pid);
      return order[(idx + 1) % order.length];
    }

    function drawUpTo(st, pid, size){
      const hand = ensure(st, pid);
      while(hand.length<size && st.deck.length>0) hand.push(st.deck.pop());
      sortAsc(hand);
    }

    function newGameState(hostId){
      const deck=[];
      for(let i=2;i<=99;i++) deck.push(i); // 98 cartes
      for(let i=deck.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [deck[i],deck[j]]=[deck[j],deck[i]];
      }
      const st = {
        deck,
        piles:[
          {value:100,ascending:false},
          {value:100,ascending:false},
          {value:1,ascending:true},
          {value:1,ascending:true}
        ],
        hands:{},
        playerOrder:[hostId],
        currentPlayerId:hostId,
        playsThisTurnByPlayer:{[hostId]:0},
        gameOver:false
      };
      drawUpTo(st, hostId, HAND_SIZE);
      return st;
    }

    function applyPlay(st, pid, handIdx, pileIdx){
      if(st.gameOver) return { ok:false, msg:"Partie terminée." };
      ensure(st, pid);
      if(!isMyTurn(st, pid)) return { ok:false, msg:"Ce n'est pas ton tour." };

      const hand = st.hands[pid];
      sortAsc(hand);
      if(handIdx<0 || handIdx>=hand.length) return { ok:false, msg:"Index carte invalide." };

      const pile = st.piles[pileIdx];
      if(!pile) return { ok:false, msg:"Pile invalide." };

      const card = hand[handIdx];
      if(!canPlay(pile, card)) return { ok:false, msg:"Coup illégal." };

      pile.value = card;
      hand.splice(handIdx,1);
      st.playsThisTurnByPlayer[pid] += 1;

      if(totalRemaining(st) === 0){
        st.gameOver = true;
        return { ok:true, msg:"Toutes les cartes ont été jouées." };
      }
      return { ok:true, msg:"OK" };
    }

    function applyEndTurn(st, pid){
      if(st.gameOver) return { ok:false, msg:"Partie terminée." };
      ensure(st, pid);
      if(!isMyTurn(st, pid)) return { ok:false, msg:"Ce n'est pas ton tour." };

      if(st.deck.length>0 && st.playsThisTurnByPlayer[pid] < MIN_PLAYS_PER_TURN){
        return { ok:false, msg:`Tu dois jouer ${MIN_PLAYS_PER_TURN} cartes avant de finir ton tour.` };
      }

      drawUpTo(st, pid, HAND_SIZE);
      st.playsThisTurnByPlayer[pid] = 0;
      st.currentPlayerId = nextPlayer(st, pid);

      if(totalRemaining(st) === 0){
        st.gameOver = true;
        return { ok:true, msg:"Toutes les cartes ont été jouées." };
      }
      return { ok:true, msg:"Tour terminé." };
    }

    /******** STOCKAGE ********/
    async function loadState(){
      if(mode==="solo") return state;
      if(!roomRef) return null;
      const snap = await roomRef.get();
      lastRoomData = snap.data() || null;
      return lastRoomData?.game || null;
    }

    async function saveState(st){
      state = st;
      if(mode==="solo") return;
      if(!roomRef) return;
      await roomRef.update({ game: st });
    }

    function subscribeRoom(code){
      if(!db) return;
      if(unsubscribeRoom) unsubscribeRoom();
      roomRef = db.collection("rooms").doc(code);

      unsubscribeRoom = roomRef.onSnapshot(s=>{
        if(!s.exists){
          setStatus("Partie introuvable / supprimée.");
          return;
        }
        lastRoomData = s.data() || {};
        state = lastRoomData.game || null;
        render();
      });
    }

    /******** PSEUDO ********/
    function requireName(){
      const n = (localName||"").trim();
      if(n.length < 2){ setStatus("Choisis un pseudo (min 2 caractères)."); return false; }
      return true;
    }

    document.getElementById("btn-save-name").onclick = ()=>{
      localName = (nameInput.value || "").trim().slice(0,12);
      localStorage.setItem("thegame_name", localName);
      setStatus(localName ? ("Pseudo enregistré : " + localName) : "Pseudo supprimé.");
      render();
    };

    /******** Couleur dynamique (calque léger) ********/
    const BLUE = {r:59,g:130,b:246};
    const RED  = {r:239,g:68,b:68};
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
    function rgba(c,a){ return `rgba(${c.r},${c.g},${c.b},${a})`; }

    // 2..49: bleu -> rouge ; 51..99: rouge -> bleu (50: neutre côté bleu->rouge)
    function gradientForValue(v){
      if(v <= 50){
        const t = clamp01((v - 2) / 47);
        const c1 = { r: lerp(BLUE.r, RED.r, t), g: lerp(BLUE.g, RED.g, t), b: lerp(BLUE.b, RED.b, t) };
        const c2 = { r: lerp(BLUE.r, RED.r, clamp01(t+0.18)), g: lerp(BLUE.g, RED.g, clamp01(t+0.18)), b: lerp(BLUE.b, RED.b, clamp01(t+0.18)) };
        return { c1: rgba(c1,.30), c2: rgba(c2,.30) };
      } else {
        const t = clamp01((v - 51) / 48);
        const c1 = { r: lerp(RED.r, BLUE.r, t), g: lerp(RED.g, BLUE.g, t), b: lerp(RED.b, BLUE.b, t) };
        const c2 = { r: lerp(RED.r, BLUE.r, clamp01(t+0.18)), g: lerp(RED.g, BLUE.g, clamp01(t+0.18)), b: lerp(RED.b, BLUE.b, clamp01(t+0.18)) };
        return { c1: rgba(c1,.30), c2: rgba(c2,.30) };
      }
    }

    function applyCardColors(el, value){
      const g = gradientForValue(value);
      el.style.setProperty("--c1", g.c1);
      el.style.setProperty("--c2", g.c2);
    }

    /******** HTML carte : numéro uniquement ********/
    function cardHTML(value){
      return `<div class="big">${value}</div>`;
    }

    /******** MODE / ROOMS ********/
    function startSolo(){
      if(unsubscribeRoom) unsubscribeRoom();
      unsubscribeRoom=null;
      roomRef=null;
      currentRoomCode=null;
      lastRoomData=null;

      mode="solo";
      state=newGameState(localPlayerId);
      selectedIndex=null;
      lastSelectedCardEl=null;
      setStatus("Mode solo.");
      hideEndScreen();
      render();
    }

    async function createOnlineRoom(){
      if(!db) return setStatus("Firebase indisponible.");
      if(!requireName()) return;

      const code = Math.random().toString(36).substring(2,6).toUpperCase();
      currentRoomCode = code;
      mode = "online";

      const st = newGameState(localPlayerId);
      const ref = db.collection("rooms").doc(code);

      await ref.set({
        code,
        createdAt: Date.now(),
        hostId: localPlayerId,
        players: { [localPlayerId]: { joinedAt: Date.now(), name: localName } },
        game: st
      });

      setStatus("Partie créée. Code : " + code);
      hideEndScreen();
      subscribeRoom(code);
    }

    async function joinOnlineRoom(){
      if(!db) return setStatus("Firebase indisponible.");
      if(!requireName()) return;

      const code = (document.getElementById("join-code-input").value || "").trim().toUpperCase();
      if(!code) return setStatus("Saisis un code.");

      const ref = db.collection("rooms").doc(code);
      const snap = await ref.get();
      if(!snap.exists) return setStatus("Partie introuvable.");

      const data = snap.data() || {};
      const st = data.game || newGameState(localPlayerId);

      ensure(st, localPlayerId);
      if(st.hands[localPlayerId].length === 0) drawUpTo(st, localPlayerId, HAND_SIZE);

      await ref.update({
        ["players."+localPlayerId]: { joinedAt: Date.now(), name: localName },
        game: st
      });

      mode = "online";
      currentRoomCode = code;
      setStatus("Rejoint " + code);
      hideEndScreen();
      subscribeRoom(code);
    }

    /******** ANIMATION ********/
    function animatePlay(cardEl, pileBtn, cardValue){
      if(!cardEl || !pileBtn) return;

      const from = cardEl.getBoundingClientRect();
      const to = pileBtn.getBoundingClientRect();

      const fly = document.createElement("div");
      fly.className = "flying-card card";
      fly.innerHTML = cardHTML(cardValue);
      applyCardColors(fly, cardValue);

      fly.style.left = from.left + "px";
      fly.style.top = from.top + "px";
      fly.style.width = from.width + "px";
      fly.style.height = from.height + "px";

      document.body.appendChild(fly);

      const dx = (to.left + to.width/2) - (from.left + from.width/2);
      const dy = (to.top + to.height/2) - (from.top + from.height/2);

      requestAnimationFrame(()=>{
        fly.style.transition = "transform 230ms ease, opacity 230ms ease";
        fly.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(.92)`;
        fly.style.opacity = "0.15";
      });

      setTimeout(()=>fly.remove(), 260);
    }

    /******** FIN DE PARTIE ********/
    function showEndScreen(){
      document.getElementById("end-deck").innerText = String(state?.deck?.length || 0);
      document.getElementById("end-total").innerText = String(state ? totalRemaining(state) : 0);
      document.getElementById("end-overlay").classList.add("show");
    }
    function hideEndScreen(){
      document.getElementById("end-overlay")?.classList.remove("show");
    }

    document.getElementById("btn-video").onclick = ()=>{
      window.open(BRAVO_VIDEO_URL, "_blank", "noopener,noreferrer");
    };
    document.getElementById("btn-close-end").onclick = hideEndScreen;
    document.getElementById("btn-replay").onclick = startSolo;

    /******** ACTIONS JEU ********/
    async function onPileClick(pileIdx){
      if(!state) return setStatus("Clique sur Reset ou crée/rejoins une partie.");
      if(selectedIndex == null) return setStatus("Choisis une carte.");

      const st = (mode==="solo") ? state : await loadState();
      if(!st) return setStatus("État introuvable.");

      ensure(st, localPlayerId);
      const hand = st.hands[localPlayerId];
      sortAsc(hand);

      const cardValue = hand[selectedIndex];
      const pileBtn = document.getElementById("pile-"+pileIdx);

      const res = applyPlay(st, localPlayerId, selectedIndex, pileIdx);
      setStatus(res.msg);

      if(res.ok){
        animatePlay(lastSelectedCardEl, pileBtn, cardValue);
        selectedIndex = null;
        lastSelectedCardEl = null;
        await saveState(st);
      }
      render();
    }

    async function onEndTurn(){
      if(!state) return setStatus("Aucune partie.");
      const st = (mode==="solo") ? state : await loadState();
      if(!st) return setStatus("État introuvable.");

      const res = applyEndTurn(st, localPlayerId);
      setStatus(res.msg);

      if(res.ok) await saveState(st);
      render();
    }

    /******** RENDER ********/
    function render(){
      updateModeBadge();
      updateRoomInfo();
      updateTurnBadge();

      if(!state){
        setInfo("Clique sur Reset ou crée/rejoins une partie.");
        document.getElementById("hand").innerHTML="";
        hideEndScreen();
        return;
      }

      ensure(state, localPlayerId);
      const hand = state.hands[localPlayerId];
      sortAsc(hand);

      if(selectedIndex != null && selectedIndex >= hand.length) selectedIndex = null;

      const deckCount = state.deck?.length || 0;
      const totalCount = totalRemaining(state);
      const plays = state.playsThisTurnByPlayer?.[localPlayerId] ?? 0;

      const myTurn = isMyTurn(state, localPlayerId);
      const disableBoard = state.gameOver || (mode==="online" && !myTurn);

      let extra = "";
      if(mode==="online" && state.currentPlayerId){
        extra += "<br/><i>C'est à <b>"+getPlayerName(state.currentPlayerId)+"</b> de jouer.</i>";
      }
      extra += "<br/><i>Coups joués ce tour : <b>"+plays+"</b> / "+MIN_PLAYS_PER_TURN+"</i>";

      setInfo(
        "Deck : <b>"+deckCount+
        "</b> — Total restant : <b>"+totalCount+
        "</b> — Ta main : <b>"+hand.length+
        "</b><br/>Carte sélectionnée : "+
        (selectedIndex!=null ? "<b>"+hand[selectedIndex]+"</b>" : "<i>Aucune</i>") +
        extra
      );

      const selectedCard = (selectedIndex!=null) ? hand[selectedIndex] : null;

      // Piles
      for(let i=0;i<4;i++){
        const btn=document.getElementById("pile-"+i);
        btn.disabled = disableBoard;

        btn.classList.remove("playable","not-playable");

        const v = state.piles[i].value;
        btn.innerHTML = cardHTML(v);
        applyCardColors(btn, v);

        if(!disableBoard && selectedCard != null){
          const ok = canPlay(state.piles[i], selectedCard);
          btn.classList.add(ok ? "playable" : "not-playable");
        }
      }

      // Main
      const handDiv=document.getElementById("hand");
      handDiv.innerHTML="";

      hand.forEach((c,i)=>{
        const el=document.createElement("div");
        el.className="hand-card card" + (selectedIndex===i ? " selected" : "");
        el.innerHTML = cardHTML(c);
        applyCardColors(el, c);

        if(disableBoard) el.classList.add("disabled");

        el.onclick=()=>{
          if(disableBoard) return setStatus("Action impossible (tour/adversaire/partie finie).");
          if(selectedIndex===i){
            selectedIndex=null;
            lastSelectedCardEl=null;
          }else{
            selectedIndex=i;
            lastSelectedCardEl=el;
          }
          render();
        };
        handDiv.appendChild(el);
      });

      if(state.gameOver) showEndScreen();
      else hideEndScreen();
    }

    /******** EVENTS ********/
    document.getElementById("btn-solo").onclick = startSolo;
    document.getElementById("btn-create-online").onclick = createOnlineRoom;
    document.getElementById("btn-join-online").onclick = joinOnlineRoom;

    document.getElementById("new-game").onclick = ()=>{
      if(mode==="online") startSolo();
      else{
        state = newGameState(localPlayerId);
        selectedIndex=null;
        lastSelectedCardEl=null;
        setStatus("Reset.");
        hideEndScreen();
        render();
      }
    };

    document.getElementById("end-turn").onclick = onEndTurn;

    for(let i=0;i<4;i++){
      document.getElementById("pile-"+i).onclick = ()=>onPileClick(i);
    }

    // init
    render();
  </script>
</body>
</html>